<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>CPN: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CPN
   </div>
   <div id="projectbrief">Computational Process Networks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">CPN Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a research and development release. There may be bugs, and things may change in future releases. If you find this useful or find a bug let us know.</p>
<p>Contacts:</p>
<ul>
<li>Greg Allen <a href="#" onclick="location.href='mai'+'lto:'+'gal'+'le'+'n@a'+'rl'+'ut.'+'ut'+'exa'+'s.'+'edu'; return false;">galle<span style="display: none;">.nosp@m.</span>n@ar<span style="display: none;">.nosp@m.</span>lut.u<span style="display: none;">.nosp@m.</span>texa<span style="display: none;">.nosp@m.</span>s.edu</a></li>
<li>John Bridgman <a href="#" onclick="location.href='mai'+'lto:'+'joh'+'nf'+'b@a'+'rl'+'ut.'+'ut'+'exa'+'s.'+'edu'; return false;">johnf<span style="display: none;">.nosp@m.</span>b@ar<span style="display: none;">.nosp@m.</span>lut.u<span style="display: none;">.nosp@m.</span>texa<span style="display: none;">.nosp@m.</span>s.edu</a></li>
</ul>
<h2>Documentation </h2>
<p>An effort to use doxygen documentation syntax was used throughout. The html pages generated by doxygen are served <a href="http://gallen.bitbucket.org/cpn-docs/">here</a>.</p>
<p>There is also a <a href="http://gallen.bitbucket.org/cpn-tutorial.pdf">tutorial PDF</a> on the basics of using the <a class="el" href="namespaceCPN.html">CPN</a> library, with example code in the directory <code>tutorial_code</code>.</p>
<p>Some details of <a class="el" href="namespaceCPN.html">CPN</a> are also available in Greg Allen's Ph.D <a href="http://users.ece.utexas.edu/~bevans/students/phd/greg_allen/">dissertation</a>.</p>
<p>The doxygen documentation can be built from the source code by running: </p>
<pre class="fragment">cd /path/to/cpn
doxygen doxygen.conf
</pre><p>The tutorial can be built (requiring LaTeX and Graphviz) by running: </p>
<pre class="fragment">cd /path/to/cpn/tutorial
make
</pre><h2>Library dependencies </h2>
<ul>
<li><a href="http://sourceforge.net/projects/cppunit/">cppunit</a> for the unit tests (can be disabled)</li>
<li><a href="http://libxmlplusplus.sourceforge.net/">libxml++</a> for XML parsing (can be disabled)</li>
<li><a href="http://fftw.org/">fftw3</a> for the beamformer example (can be disabled)</li>
<li><a href="http://bitbucket.org/gallen/libvariant">libvariant</a> for configuration management and data serialization</li>
</ul>
<h2>Tests </h2>
<p>The unit tests require <a href="http://sourceforge.net/projects/cppunit/">cppunit</a>. All of the tests are in the test directory.</p>
<h2>Changes since last release </h2>
<ul>
<li>Moved the Variant class and serializers into a separate library, <a href="http://bitbucket.org/gallen/libvariant">libvariant</a>.</li>
<li>Bug fixes.</li>
<li>Added Flush and Reset semantics to the queues</li>
</ul>
<h2>Previous Changes </h2>
<ul>
<li>Convert to autotools</li>
<li>Convert to use libtool</li>
<li>Change default node loading behavior</li>
<li>Put project on bitbucket</li>
<li>Setup a way to install/uninstall the library into the system with included pkg-config files.</li>
<li>Added example of an auxilary library that could be installed along side <a class="el" href="namespaceCPN.html">CPN</a> to add extra nodes.</li>
</ul>
<h2>Applications </h2>
<p>Two applications are provided with this library. They are RemoteContext and CPNKernel.</p>
<h3>CPNKernel</h3>
<p>This is a loader application which takes a set of command line options and configuration files and loads up a <a class="el" href="namespaceCPN.html">CPN</a> network. This expects that all the nodes can be looked up with the node loader. (See Node Library section below)</p>
<h3>RemoteContext</h3>
<p>This is a realization of a centralized version of the remote context daemon over sockets. See the output to the <code>-h</code> option for details on how to run.</p>
<h2>Examples and case studies </h2>
<p>These are all located in the examples directory. All applications here support the <code>-h</code> option to gives some documentation how usage.</p>
<h3>Seive of Eratosthenes</h3>
<p>There are two versions of this, the first is called SimpleSieve and the second is called ThresholdSieve. The code is for these is under <code>examples/SieveOfEratosthenes</code>. Use the <code>-h</code> option to get specific options.</p>
<h3>Random Instruction</h3>
<p>There are two versions of the random instruction case study. Both are in the <code>examples/RandomInstruction</code> directory. The first version instantiates the random instruction nodes in a single process and is named <code>RandomInstruction</code>. Run with <code>-h</code> to get a list of options.</p>
<p>The second version exercises the remote queue/context functionality. This version is called <code>RemoteRandomInstruction</code>. The <code>-h</code> option gives some details on how to run it. The remote random instruction takes a config file that tells it how to create notes on what processes and what processes exist. See the <code>-h</code> option and the example config <code>configk2n100i100</code> in the same directory for examples of the configuration file. To run this first run the RemoteContext then run each of the processes. For the example config we might run: </p>
<pre class="fragment">Run on zeus: RemoteContext zeus 12345
Run: RemoteRandomInstruction configk2n100i100 kone zeus 12345
Run: RemoteRandomInstruction configk2n100i100 ktwo zeus 12345
</pre><p>This would run the RemoteContext daemon on zeus then create two instances of the remote random instruction each named kone and ktwo.</p>
<h3>Beamformer</h3>
<p>There are several implementations in one directory. These provide basic command line driven ways of running the different parts of the beamformer and several different tests. Use the -h option on each after it has been built for options on how to run them.</p>
<h3>DeflateNode</h3>
<p>This is a full blown example project for a node that gets installed along side the <a class="el" href="namespaceCPN.html">CPN</a> library. There are included json config files for the CPNKernel that give an example of what they can do. These nodes use the zlib compression library to implement compression and decompression nodes.</p>
<h2>About External Endpoints </h2>
<p>External endpoints are a special handle to a queue endpoints that is not associated with a node. This is useful for the case where you want to input or output data to the network of nodes. For example, instantiate some network of nodes, then create two endpoints to be input and output. Then this allows for the application to grab endpoints outside of a node for putting data in and out. One has to be careful though as all the same rules apply for determinism and deadlock. The idea behind this was that <a class="el" href="namespaceCPN.html">CPN</a> could be used in a larger application where <a class="el" href="namespaceCPN.html">CPN</a> is just a library used to compute some intermediate value for the application. One of the design goals in mind while writing <a class="el" href="namespaceCPN.html">CPN</a> was that it should be usable in as many situations as possible.</p>
<p>Example: </p>
<pre class="fragment">kernel.CreateExternalWriter("writer name");
... generate queues...
CPN::OQueue&lt;int&gt; out = kernel.GetExternalOQueue("writer name");
while (data) {
    ...
    out.Enqueue(...);
    ...
}
out.Release();
...

kernel.DestroyExternalEndpoints("writer name");
</pre><h2>About Function Nodes </h2>
<p>These are nodes that can be created by passing a function or function object to the kernel. It is setup with templates to allow for the passing of up to 9 parameters to a function node. The idea here is that sometimes one wants a simple node where writing all the machinery for a full blown node would be overkill. This feature is used in the tests in several places where writing a full node would have been painfully verbose.</p>
<p>Example: </p>
<pre class="fragment">void testnode(CPN::NodeBase * node, std::string endpoint) {
    CPN::IQueue&lt;int&gt; in = node-&gt;GetIQueue(endpoint);
    ... read from in
}

...
in setup do
...
kernel.CreateFunctionNode("node name", testnode, std::string("endpoint name"));
</pre><h2>Node Library </h2>
<p>One of the features is dynamic node type loading. The way this works is that there is a node loader class which has a list of places to search for nodes. The first thing the node loader does is look through the symbol table of the program for a symbol which is a mangling of the node type name. If this symbol is found it will call it as a function to get a node factory for that node type. If it is not found then it will look into an internal dictionary to see if some dynamic library can be loaded which will provide the symbol. The way the node loader knows if there is a library it can load is by telling it with a node list file. The node list file has a very simple syntax. There are two kinds of directives, include and defining a node type name and its library. The include is simply the keyword include followed by arbitrary white space then a list of files to include separated by white space. All commands end in a semicolon. The library node type name is the keyword lib followed by white space then the name of the dynamic library to load followed by white space then the mangled node type name and finished with a semicolon. By default the node loader will look into ${prefix}/cpnnodes for files matching <code>*.nodelist</code> and load them as additional node lists.</p>
<p>There are some default nodes contained in the <code>nodelib</code> directory.</p>
<h2>Defining A Node </h2>
<p>To define a node, subclass <code><a class="el" href="classCPN_1_1NodeBase.html" title="The definition common to all nodes in the process network. ">CPN::NodeBase</a></code>. Then somewhere in the implementation file put the macro <code><a class="el" href="NodeBase_8h.html#a48779f5e3b563eec347454d8e4581b20">CPN_DECLARE_NODE_FACTORY(typename, classname)</a>;</code>. Note that typename must be a valid as a symbol name. There is also a macro <code><a class="el" href="NodeBase_8h.html#af2f65318af7152c582e8a68c03306f6a">CPN_DECLARE_NODE_AND_FACTORY(typename, classname)</a>;</code> which allows one to declare the node and factory all at once and all that is required is a definition of the <code>classname::Process()</code> function. This allows stateless nodes to be created more easily. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
